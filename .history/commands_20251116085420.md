adb logcat -c
Launch the app, tap “Open GDL90 PDF” to trigger the crash.
adb logcat -d | grep -E "com\\.CompanyName\\.AvaloniaHello|FATAL EXCEPTION|AndroidRuntime" (or save the log and share the section around the crash).clear

Key Constraints

You want a single Avalonia UI layer, not separate Xamarin-style views per platform.
Current MuPDFCore renderer covers Windows/macOS/Linux only; Android/iOS binaries are missing.
You still need an in-app viewer (external intents are only a stopgap), but any platform-specific work should be thin and isolated.
Option Review

Platform-native embeds (Android Jetpack androidx.pdf, iOS PDFKit/QuickLook) hosted inside Avalonia via IPlatformHandle/PlatformEmbeddedView keep rendering code slim (≈300–500 lines per platform) and leverage OS-level PDF stacks. You maintain one Avalonia view + one adapter per platform, no native toolchain work.
Porting MuPDF to Android/iOS yourself requires building and packaging native libs for every ABI (arm64-v8a, armeabi-v7a, x86_64, etc.), wiring JNI bindings, and keeping them in sync with Avalonia updates—high setup cost plus continuous maintenance.
WebView-based pdf.js is theoretically cross-platform but needs high-memory WebView hosting on every OS, lacks form/annotation parity, and struggles offline; still forces per-platform WebView glue.
External viewer intents (current Android behavior) are lowest effort but break the in-app experience and can’t guarantee UX parity.
Best Path
Adopt a platform-abstraction layer around PDF viewing: define an IPdfPresenter service in shared Avalonia code, back it with the existing MuPDF control on desktop, Jetpack viewer on Android, PDFKit on iOS, and fall back to launcher when no native stack exists. You write each native host once, expose it through a tiny bridge, and the rest of the app remains identical everywhere. This gives you guaranteed support (each OS vendor maintains their renderer) and keeps your maintenance surface limited to thin interop files rather than whole UI stacks or native build pipelines.

Suggested Next Steps

Sketch the shared IPdfPresenter interface and swap AppViewModel to request it via DI.
Implement DesktopPdfPresenter by wrapping your existing MuPDF control (basically current behavior).
Prototype AndroidPdfPresenter: host PdfRendererView inside Avalonia using AndroidViewControl, feed it your Stream, and ensure lifecycle disposal.
Mirror that pattern for iOS with PDFView/QLPreviewController.
Keep the intent-based launcher as a fallback until both presenters are shippable.
This route aligns with your “one UI codebase” goal while avoiding an endless chase of compiling third-party PDF binaries for every target. Let me know if you want a spike outline or code skeleton for the Android/iOS presenters.